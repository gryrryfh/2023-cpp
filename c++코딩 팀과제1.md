# 코딩 팀과제
## 팀원 이재경 추승범
## 전위 ++ 연산자 오버로딩, 후위 ++ 연산자 오버로딩의 예를 만들고 설명을 적으시오.
```c++
#include<iostream>
using namespace std;
class Counter{
	private: int value;
	public:
		Counter(){
			value=0;
		}
		Counter(int v){
			value = v;
		}
		Counter operator++(int) {	//후위 
			Counter temp = *this;
			++value;
			return temp;
		}
		Counter operator++(){ 		//전위
			value++;
			return *this;
		}
		int getValue(){
			return value;
		}
};
class CRect{						// 사각형 CRect cla
ss 
	private: int w,h;
	public:
		CRect(int _w, int _h){
			w=_w, h=_h;
		}
		int Area(){
			return w*h ;
		}
};
int main(){
	Counter c;
	Counter c1;
	
	for(int i; i<5 ; i++){
	Counter temp = c++;
	Counter temp1 = ++c1;
	
	CRect r(temp.getValue(),10);
	CRect r1(temp1.getValue(),10);
	
	cout << "temp 사각형의 넓이 : "<<r.Area()<<"		";
	cout << "c 사각형의 넓이 : "<<r1.Area()<< endl;
	}
}
```

## STL로 stack을 5개 만들고, 50, 40, 30, 20, 10을 저장하고, 출력 하는 것을 iterator를 활용하시오
```c++
#include<iostream>
#include<vector>
#include<stack>
using namespace std;

int main(){

    stack<int> s;
    s.push(50);
    s.push(40);
    s.push(30);
    s.push(20);
    s.push(10);


    vector<int> v;
    v.push_back(s.top());
    s.pop();
    v.push_back(s.top());
    s.pop();
    v.push_back(s.top());
    s.pop();
    v.push_back(s.top());
    s.pop();
    v.push_back(s.top());

    vector<int>::iterator it;

    for(it = v.begin(); it != v.end(); ++it){
        cout << *it << endl;
    }

}
```
## ChatGPT를 활용하여 STL의 자료구조와 알고리즘을 분류하고, 자료구조 예제 1개와 알고리즘 1개를 만들고 토의를 하시오.
### 자료구조
#### Sequence Containers (순차적 자료 구조)
* vector: 동적 배열을 나타내는 자료 구조
* list: 이중 연결 리스트를 나타내는 자료 구조
* deque: 더블 엔딩 큐를 나타내는 자료 구조
* array: 정적 배열을 나타내는 자료 구조

#### Associative Containers (연관된 자료 구조)
* set: 원소를 오름차순으로 정렬하여 저장하는 자료 구조
* multiset: set과 동일하지만 중복된 원소를 허용하는 자료 구조
* map: 키와 값의 쌍을 저장하는 자료 구조로, 키를 오름차순으로 정렬하여 저장
* multimap: map과 동일하지만 중복된 키를 허용하는 자료 구조

#### Unordered Associative Containers (비정렬 연관된 자료 구조)
* unordered_set: 해시 테이블을 사용하여 원소를 저장하는 자료 구조
* unordered_multiset: unordered_set과 동일하지만 중복된 원소를 허용하는 자료 구조
* unordered_map: 해시 테이블을 사용하여 키와 값의 쌍을 저장하는 자료 구조
* unordered_multimap: unordered_map과 동일하지만 중복된 키를 허용하는 자료 구조

#### Container Adapters (자료 구조를 변형하는 어댑터)
* stack: LIFO(Last In First Out) 방식으로 원소를 저장하는 자료 구조
* queue: FIFO(First In First Out) 방식으로 원소를 저장하는 자료 구조
* priority_queue: 원소가 우선순위에 따라 정렬되어 저장되는 자료 구조

### 자료구조 예시
```c++
```
### 알고리즘
* 정렬 알고리즘 (Sorting Algorithms): STL의 sort() 함수를 사용하여 오름차순 또는 내림차순으로 정렬할 수 있다. 이를 위해서는 원소들이 비교 가능한 연산자(operator<)를 정의해야 한다.

* 이진 검색 알고리즘 (Binary Search Algorithms): STL의 binary_search() 함수를 사용하여 정렬된 벡터 또는 배열에서 이진 검색을 할 수 있다.

* 병합 알고리즘 (Merge Algorithms): STL의 merge() 함수를 사용하여 두 개의 정렬된 벡터 또는 배열을 병합할 수 있다.

* 순열 알고리즘 (Permutation Algorithms): STL의 next_permutation() 함수와 prev_permutation() 함수를 사용하여 주어진 범위에서 다음 순열과 이전 순열을 생성할 수 있다.

* 최소/최대 알고리즘 (Min/Max Algorithms): STL의 min() 함수와 max() 함수를 사용하여 주어진 두 값 중에서 최소값과 최대값을 구할 수 있다.

* 범위 알고리즘 (Range Algorithms): STL의 copy() 함수, fill() 함수, remove() 함수, replace() 함수 등을 사용하여 범위 내의 값을 다른 범위로 복사하거나, 지정한 값으로 채우거나, 지정한 값으로 대체할 수 있다.

* 순차적 알고리즘 (Sequential Algorithms): STL의 accumulate() 함수, inner_product() 함수, partial_sum() 함수 등을 사용하여 순차적으로 값을 계산할 수 있다.

* 그래프 알고리즘 (Graph Algorithms): STL의 다양한 자료구조와 알고리즘을 활용하여 그래프를 다룰 수 있다. 예를 들어, 인접 리스트를 사용하여 그래프를 구현하고, BFS 알고리즘과 DFS 알고리즘을 적용하여 탐색할 수 있다.

### 알고리즘 예시
```c++
```

## C++의 주요 특징 20가지의 제목을 적어 보고 토의 하시오.
객체 지향 프로그래밍
일반화 프로그래밍 (Generic Programming)
자동 메모리 관리 (Automatic Memory Management)
템플릿 메타프로그래밍 (Template Metaprogramming)
인라인 함수 (Inline Function)
참조 변수 (Reference Variable)
네임스페이스 (Namespace)
예외 처리 (Exception Handling)
표준 라이브러리 (Standard Library)
다중 상속 (Multiple Inheritance)
가상 함수 (Virtual Function)
추상 클래스 (Abstract Class)
연산자 오버로딩 (Operator Overloading)
캡슐화 (Encapsulation)
상속 (Inheritance)
다형성 (Polymorphism)
STL (Standard Template Library)
RAII (Resource Acquisition Is Initialization)
함수 객체 (Function Object)
스마트 포인터 (Smart Pointer)
위의 특징들은 C++을 사용할 때 유용하게 사용할 수 있는 다양한 기능들입니다. 예를 들어, 객체 지향 프로그래밍은 코드의 재사용성과 유지보수성을 향상시키는 데 도움을 줍니다. 또한, 템플릿 메타프로그래밍을 통해 실행 시간이 아닌 컴파일 시간에 처리되는 코드를 작성할 수 있어서 빠른 속도와 효율성을 가지게 됩니다.

STL은 C++의 표준 라이브러리로, 다양한 자료구조와 알고리즘을 제공하여 편리하게 사용할 수 있도록 해줍니다. RAII와 스마트 포인터는 메모리 관리에 대한 편리한 방법을 제공하여 메모리 누수와 같은 문제를 예방할 수 있도록 합니다.

이러한 특징들은 C++을 다른 언어와 구별되게 만들어주는 중요한 요소입니다. C++의 다양한 특징들을 활용하여 개발자는 보다 효율적이고 안정적인 코드를 작성할 수 있습니다.

